#after the imports:

# if the matrix size changes, update the size of the dependent matrix, the first for loop, the size of the table.


#before Matrix = -----:
#Y_j_LIST.insert(0, 'blank')  # for adding this to the table( 'blank' will not be displayed on the table )



# create table of size 6 rows, 3 columns. 1 row is for the header and 5 rows are for the results.


# Table = [[0.0, 0.0, 0.0] for x in range(6)]
#
#
# # add the values of Y_j to the table
# counter1 = 0  # used to reference the index of Y_j_LIST
# for nested_lists in Table:
#     nested_lists[0] = Y_j_LIST[counter1]
#     counter1 += 1
#
# # add values of solutions to table
# counter2 = 0
# counter3 = 0  # since values of row 2 and last row will always be 0, we need to skip those rows. This is the purpose of this variable
# for nested_lists2 in Table:
#     counter3 += 1
#     if counter3 <= 2:
#         continue
#     nested_lists2[1] = result_withNumPy[counter2][0]
#     counter2 += 1
#
#     if counter2 == len(result_withNumPy):
#         break
#
# # add values of exact velocities to table
# counter4 = 0
# counter5 = 0  # since values of row 2 and last row will always be 0, we need to skip those rows. This is the purpose of this variable
# for nested_lists3 in Table:
#     counter5 += 1
#     if counter5 <= 1:
#         continue
#     nested_lists3[2] = V_exact_LIST[counter4]
#     counter4 += 1
#
#     if counter4 == len(V_exact_LIST):
#         break
#
# # assign values for the headers (first row)
# Table[0][0] = "Y_j"
# Table[0][1] = "Solution"
# Table[0][2] = "V Exact"





#print("\n\nTable: \n", tb(Table))
#NOTE: use showindex=True to count how many rows there are in the table
